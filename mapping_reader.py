#!/usr/bin/env python
# coding: utf-8

#
# MIMIC-BP - (C) 2024
# https://doi.org/10.7910/DVN/DBM1NF
#
# Open Data Commons Open Database License (ODbL) v1.0
# https://opendatacommons.org/licenses/odbl/1-0/
#

"""
Expected input:
    -T N (duration of window N seconds)
    -f --fname (generated by mapping_generator.py, e.g. mimic_mapping.csv)
    -d --dbpath PATH
    Optional input flags:
    -v --verbose (if present, prints additional messages)
    -p --plotting (if present, activates plotting)
    -i --invppg (if present, inverts PPG signal; used only when plotting)

Expected output:
    Files of the form
    mapping_T*_DeltaBP*_SBPmin*_DBPmax*_MaxSeg*.txt
    Example

    > head mapping_T30_DeltaBP25_SBPmin60_DBPmax120_MaxSeg10.txt
    T = 30 seconds - N = 3750 samples per segment
    n0 - index of first sample of each segment
    n0,SBP,DBP
    0 - p00/p009258/3013677_0026:
    1 - p00/p009258/3013677_0014:
    2 - p00/p009258/3013677_0029:
    3 - p00/p009258/3013677_0017:
    57723,80.8,35.0
    60314,83.1,36.6
    65051,82.7,35.6
    etc.
    Above, only record 3 contains valid 30-second segments, the first
    starting at index 57723 and SBP & DBP labels 80.8 and 35.0, respectively
    the second at index 60314 and SBP & DBP labels 83.1 and 36.6 respectively
    etc.


# Example:
Usage example 1: (just processing, no plotting required)
> python mapping_reader.py -d /data-local/Blood-Pressure/files
                           -f mimic_mapping.csv -T 30 > mapping_reader.log
Then, check output files of the form:
    mapping_T30_DeltaBP*_SBPmin*_DBPmax*_MaxSeg*.txt
    For example, picking one of the files, note that:
    > head mapping_T30_DeltaBP25_SBPmin60_DBPmax120_MaxSeg10.txt
    should result something as above, under 'Expected output:'

Usage example 2: (when plotting)
> python mapping_reader.py -d /data-local/Blood-Pressure/files
                           -f mimic_mapping.csv -T 10 -p
No output files in this case
"""
import re
import wfdb
import numpy as np
import pandas as pd
import argparse


def BPconfParams() -> dict:
    """
    Returns dictionary with blood pressure limits

    Key values:
        DeltaBP': maximum variation allowed for SBP or DBP, in mmHg
        STDmax': maximum standard deviation allowed for SBP or DBP
        BPmax': maximum allowed value for BP
        BPmin': minimum allowed value for BP
        SBPmin': minimum allowed value for SBP
        DBPmax': maximum allowed value for DBP
        PulsePressureMax': maximum allowed value for pulse pressure
        NPP': constant related to pulse pressure
    """
    BPconf = {
        "DeltaBP": 25,  # mmHg
        "STDmax": 4,  # mmHg
        "BPmax": 200,  # mmHg
        "BPmin": 30,  # mmHg
        "SBPmin": 60,  # 'SBPmin': 90, 'SBPmax': 180,  # see Baek, 2019
        "DBPmax": 120,  # 'DBPmin': 60,  # see Baek, 2019
        "PulsePressureMax": 100,  # healty pulse pressure = 40 mmHg
        # narrow pulse pressure when SBP - DBP < SBP/NPP, with NPP = 4
        "NPP": 4,
    }
    return BPconf


def bp_val_assert(abp, sbp, dbp, verbose):
    assert isinstance(
        abp, (list, tuple, np.ndarray)
    ), f'Input "abp" must be of type "list", "tuple" or "numpy.ndarray", got {type(abp)}'
    assert isinstance(
        sbp, (list, tuple, np.ndarray)
    ), f'Input "sbp" must be of type "list", "tuple" or "numpy.ndarray", got {type(sbp)}'
    assert isinstance(
        dbp, (list, tuple, np.ndarray)
    ), f'Input "dbp" must be of type "list", "tuple" or "numpy.ndarray", got {type(dbp)}'
    assert isinstance(
        verbose, bool
    ), f'Input "verbose" must be of type "bool", got {type(verbose)}'
    assert (
        len(np.array(abp).shape) == 1
    ), f'Argument "abp" must be a 1-D array, list or tuple; but received input is {len(np.array(abp).shape)}-D'
    assert (
        len(np.array(sbp).shape) == 1
    ), f'Argument "sbp" must be a 1-D array, list or tuple; but received input is {len(np.array(sbp).shape)}-D'
    assert (
        len(np.array(dbp).shape) == 1
    ), f'Argument "dbp" must be a 1-D array, list or tuple; but received input is {len(np.array(dbp).shape)}-D'


def bp_minmax_checks(
    sbp,
    dbp,
    max_sbp,
    min_sbp,
    max_dbp,
    min_dbp,
    BPmax,
    BPmin,
    SBPmin,
    DBPmax,
    DeltaBP,
    verbose,
):
    if max_sbp - min_sbp > DeltaBP:
        if verbose:
            print(f"max(sbp) - min(sbp) > DeltaBP = {DeltaBP}")
        return False
    if max_dbp - min_dbp > DeltaBP:
        if verbose:
            print(f"max(dbp) - min(dbp) > DeltaBP = {DeltaBP}")
        return False
    if max_sbp > BPmax:
        if verbose:
            print(f"max(sbp) > BPmax = {BPmax}")
        return False
    if min_sbp < SBPmin:
        if verbose:
            print(f"min(sbp) < SBPmin = {SBPmin}")
        return False
    if min_dbp < BPmin:
        if verbose:
            print(f"min(dbp) < BPmin = {BPmin}")
        return False
    if max_dbp > DBPmax:
        if verbose:
            print(f"max(dbp) > DBPmax = {DBPmax}")
        return False
    if np.any(sbp < dbp):
        if verbose:
            print("any(sbp < dbp)")
        return False
    return True


def check_bp_std(sbp, dbp, STDmax, verbose):
    sbp_std = np.std(sbp, ddof=1)
    dbp_std = np.std(dbp, ddof=1)
    max_std = max(sbp_std, dbp_std)
    if max_std > STDmax:
        if verbose:
            print(f"max(sbp_std, dbp_std) = {max_std:.1f} > STDmax = {STDmax}")
        return False
    return True


def check_PP_NPP(
    abp, SBP, DBP, PulsePressureMax, NPP, verbose, n0, Ns, DeltaBP
):
    if SBP - DBP > PulsePressureMax:
        if verbose:
            print(f"SBP - DBP > PulsePressureMax = {PulsePressureMax}")
        return False
    if SBP - DBP < SBP / NPP:  # narrow pulse pressure if SBP - DBP < SBP/4
        if verbose:
            print(f"SBP - DBP < SBP/4 = {SBP/NPP:.1f}")
        return False

    # loose check against ABP signal samples
    sabp = abp[n0 : n0 + Ns]
    maxABP = np.max(sabp)
    minABP = np.min(sabp)
    if maxABP > SBP + DeltaBP or minABP < DBP - DeltaBP:
        return False

    return True


def validate_BP(
    abp: "list, tuple, np.ndarray",
    n0: int,
    Ns: int,
    sbp: "list, tuple, np.ndarray",
    dbp: "list, tuple, np.ndarray",
    verbose: bool = False,
) -> tuple:
    """
    Returns SBP and DBP. Returns NaN if inclusion criteria are not met.

    Parameters
    ----------
    abp: 'list, tuple, np.ndarray'
        The 1-d array containing the ABP signal samples

    n0: int
        Index of first sample of segment

    Ns: int
        Number of samples in segment

    sbp: 'list, tuple, np.ndarray'
        The 1-d array containing the SBP values

    dbp: 'list, tuple, np.ndarray'
        The 1-d array containing the DBP values

    verbose: bool = False
        Whether or not to print inclusion criteria test results.
        Default is False.


    Returns
    -------
    SBP, DBP: tuple
        The SBP and DBP values to be used as target for AI model training.
        Returns (np.nan, np.nan) if at least one of the inclusion criteria
        isn't satisfied.
    """
    bp_val_assert(abp, sbp, dbp, verbose)
    BPconf = BPconfParams()

    DeltaBP = BPconf["DeltaBP"]
    STDmax = BPconf["STDmax"]
    BPmax = BPconf["BPmax"]
    BPmin = BPconf["BPmin"]
    SBPmin = BPconf["SBPmin"]
    DBPmax = BPconf["DBPmax"]
    PulsePressureMax = BPconf["PulsePressureMax"]
    NPP = BPconf["NPP"]

    max_sbp = np.max(sbp)
    min_sbp = np.min(sbp)
    max_dbp = np.max(dbp)
    min_dbp = np.min(dbp)
    flag = bp_minmax_checks(
        max_sbp=max_sbp,
        min_sbp=min_sbp,
        DeltaBP=DeltaBP,
        verbose=verbose,
        sbp=sbp,
        dbp=dbp,
        max_dbp=max_dbp,
        min_dbp=min_dbp,
        BPmax=BPmax,
        BPmin=BPmin,
        SBPmin=SBPmin,
        DBPmax=DBPmax,
    )
    if not flag:
        return np.nan, np.nan

    flag = check_bp_std(sbp=sbp, dbp=dbp, STDmax=STDmax, verbose=verbose)
    if not flag:
        return np.nan, np.nan

    SBP = np.median(sbp)
    DBP = np.median(dbp)

    flag = check_PP_NPP(
        abp=abp,
        SBP=SBP,
        DBP=DBP,
        PulsePressureMax=PulsePressureMax,
        NPP=NPP,
        verbose=verbose,
        n0=n0,
        Ns=Ns,
        DeltaBP=DeltaBP,
    )
    if not flag:
        return np.nan, np.nan

    return SBP, DBP


def find_segments(conf: str, N: int) -> list:
    """
    Returns a list containing the starting and ending point of sequences of N
    ones in conf, i.e, start and end of reliable segments of data

    Parameters
    ----------
    conf: str
        Confidence flag values stored in a string, separated by excactly one
        empty space (same format as in feature_map)

    N: int
        Number of heartbeats classified as reliable in order for the segment
        to be considered reliable


    Returns
    -------
    out: list
        A list containing the start and end of reliable segments of data
    """
    assert isinstance(
        conf, str
    ), f'Input "conf" must be of type "str", got {type(conf)}'
    assert isinstance(
        N, int
    ), f'Input "N" must be of type "int", got {type(N)}'
    assert N > 0, f'Input "N" must be > 0, got N = {N}'
    conf = np.array([int(n) for n in conf.split()])
    i, Nc = 0, len(conf)
    nones = 0
    out = []
    while i < Nc - N + 1:
        while i < Nc - N + 1 and conf[i] == 1 and nones < N:
            i += 1
            nones += 1
        if nones == N:
            out.append((i - N, i - 1))
        else:
            i += 1
        nones = 0
    return out


def not_plotting_fout_write(plotting, T, BPconf, MaxSegments_per_patient, Ns):
    if not plotting:
        fout = (
            f'mapping_T{T}_DeltaBP{BPconf["DeltaBP"]}'
            + f'_SBPmin{BPconf["SBPmin"]}'
            + f'_DBPmax{BPconf["DBPmax"]}'
            + f"_MaxSeg{MaxSegments_per_patient}.txt"
        )
        print(fout)
        fpout = open(fout, "w", buffering=1)
        fpout.write(f"T = {T} seconds - N = {Ns} samples per segment\n")
        fpout.write(f"n0 - index of first sample of each segment\n")
        fpout.write(f"n0,SBP,DBP\n")
        return fout, fpout
    return None, None


def plot_main(abp, SBP, DBP, plotting, df, invppg, n0, Ns, fs, record_fn):
    if plotting:
        import pat
        import matplotlib.pyplot as plt

        ecg = np.array(df["II"])
        ecg[np.isnan(ecg)] = 0  # converting ecg nan to 0
        ppg = np.array(df["PLETH"]) * invppg
        ppg[np.isnan(ppg)] = 0  # converting ppg nan to 0
        # signals passed through the same filter of
        # pat.FEAT_R() analysis
        ecg = pat.butter_filter(ecg, pat.fc1ecg, pat.fc2ecg, fs, pat.order)
        ppg = pat.butter_filter(ppg, pat.fc1ppg, pat.fc2ppg, fs, pat.order)

        indn = range(n0, min(n0 + Ns, len(ecg)))
        t = np.array(indn) / fs

        fig1, ax1 = plt.subplots(figsize=(20, 4))
        cecg = "tab:blue"
        ax1.set_xlabel("Time [s]")
        ax1.set_ylabel("ECG", c=cecg)
        ax1.set_title(record_fn)
        ax1.grid(
            visible=True, color="aqua", alpha=0.3, linestyle="-.", linewidth=1
        )
        ax1.plot(t, ecg[indn], c=cecg)
        ax1.tick_params(axis="y", labelcolor=cecg)
        ax1 = ax1.twinx()
        cppg = "tab:green"
        ax1.set_ylabel("PPG", c=cppg)
        ax1.plot(t, ppg[indn], c=cppg)
        ax1.tick_params(axis="y", labelcolor=cppg)
        fig1.tight_layout()
        plt.show()

        fig2, ax2 = plt.subplots(figsize=(20, 4))
        cabp = "tab:orange"
        ax2.set_xlabel("Time [s]", c=cabp)
        ax2.set_ylabel("ABP", c=cabp)
        ax2.set_title(record_fn)
        ax2.grid(
            visible=True, color="aqua", alpha=0.3, linestyle="-.", linewidth=1
        )
        ax2.plot(t, abp[indn], c=cabp)
        ax2.tick_params(axis="y", labelcolor=cabp)
        ax2.tick_params(axis="x", labelcolor=cabp)
        msg = f" sbp = {SBP:.1f}\n dbp = {DBP:.1f}"
        ax2.text(
            1 / 2 * (max(t) - min(t)) + min(t),
            80,
            msg,
            fontsize=20,
            fontweight="bold",
        )
        ax2 = ax2.twinx()
        cppg = "tab:green"
        ax2.set_ylabel("PPG", c=cppg)
        ax2.plot(t, ppg[indn], c=cppg)
        ax2.tick_params(axis="y", labelcolor=cppg)
        fig2.tight_layout()
        plt.show()


def not_plotting_nsegs_limit(
    SBP,
    DBP,
    count,
    record_fn,
    Segments_per_patient,
    MaxSegments_per_patient,
    UniquePatients,
    UniquePatientsMax,
    fpout,
    n0,
):
    # limit the number of segments per patient
    if not np.isnan(SBP):
        m = re.search("(^p.+)/(.+)/(.+)$", record_fn)
        patient = m.group(2)
        if patient in Segments_per_patient:
            Segments_per_patient[patient] += 1
        else:
            Segments_per_patient[patient] = 1
            UniquePatients += 1
        if Segments_per_patient[patient] == MaxSegments_per_patient:
            UniquePatientsMax += 1
        if Segments_per_patient[patient] <= MaxSegments_per_patient:
            fpout.write(f"{n0},{SBP:.1f},{DBP:.1f}\n")
            count += 1
    return Segments_per_patient, UniquePatients, UniquePatientsMax, count


def not_plotting_print(
    plotting,
    count,
    T,
    UniquePatients,
    UniquePatientsMax,
    MaxSegments_per_patient,
    fout,
    fpout,
):
    if not plotting:
        print(
            f"\nA total of {count} segments of {T} seconds each, "
            + f"corresponding to {count*T/3600:.1f} hours"
        )
        print(f"Unique patients: {UniquePatients}")
        print(
            f"Patients with at least {MaxSegments_per_patient} segments: {UniquePatientsMax}"
        )
        print(
            f"Maximum number of segments per patient: {MaxSegments_per_patient}"
        )
        print(f"Please, see the file <{fout}>\n")
        fpout.close()


def main(args) -> None:
    """Processing a sequence of records"""
    invppg = -1 if args.invppg else 1
    dbpath = args.dbpath
    fname = args.fname
    T = args.duration
    verbose = args.verbose
    plotting = args.plotting

    if T < 1:
        parser.error("T must be greater than 1")

    chunksize = 1
    fs = 125  # sampling frequency, Hz
    N = int(T * 3.5)  # number of beats
    Ns = int(T * fs)  # number of samples in T seconds
    BPconf = BPconfParams()

    for MaxSegments_per_patient in [60000]:
        Segments_per_patient = {}
        count = 0  # keeps number of acceptable segments of T seconds
        UniquePatients = 0
        UniquePatientsMax = 0  # no. of patients with at least MaxSegs
        fout, fpout = not_plotting_fout_write(
            plotting=plotting,
            T=T,
            BPconf=BPconf,
            MaxSegments_per_patient=MaxSegments_per_patient,
            Ns=Ns,
        )

        with pd.read_csv(fname, chunksize=chunksize) as reader:
            for idx, chunk in enumerate(reader):
                record_fn = chunk["fname"][idx]
                msg = f"{idx} - {record_fn}:\n"
                record_fn_full = dbpath + "/" + record_fn
                record = wfdb.rdrecord(record_fn_full)
                # getting signals of interest (abp, ppg, ecg-ii)
                df = pd.DataFrame(record.p_signal, columns=record.sig_name)
                abp = np.array(df["ABP"])
                abp[np.isnan(abp)] = 0  # converting abp nan to 0
                if verbose:
                    print(msg)
                if not plotting:
                    fpout.write(msg)
                ppg_start = chunk["ppg_start"][idx]
                ppg_start = np.array([int(n) for n in ppg_start.split()])
                sbp = chunk["sbp"][idx]
                sbp = np.array([float(n) for n in sbp.split()])
                dbp = chunk["dbp"][idx]
                dbp = np.array([float(n) for n in dbp.split()])
                conf = chunk["conf"][idx]
                mm = find_segments(conf, N)
                for i in mm:
                    i_start = i[0]
                    i_end = i[1]
                    n0 = ppg_start[i_start]

                    # BP analysis: exclusion criteria
                    SBP, DBP = validate_BP(
                        abp,
                        n0,
                        Ns,
                        sbp[i_start : i_end + 1],
                        dbp[i_start : i_end + 1],
                        verbose,
                    )

                    if not plotting:
                        if np.isnan(SBP):
                            continue

                        (
                            Segments_per_patient,
                            UniquePatients,
                            UniquePatientsMax,
                            count,
                        ) = not_plotting_nsegs_limit(
                            SBP=SBP,
                            DBP=DBP,
                            count=count,
                            record_fn=record_fn,
                            Segments_per_patient=Segments_per_patient,
                            MaxSegments_per_patient=MaxSegments_per_patient,
                            UniquePatients=UniquePatients,
                            UniquePatientsMax=UniquePatientsMax,
                            fpout=fpout,
                            n0=n0,
                        )
                    else:
                        plot_main(
                            abp=abp,
                            SBP=SBP,
                            DBP=DBP,
                            plotting=plotting,
                            df=df,
                            invppg=invppg,
                            n0=n0,
                            Ns=Ns,
                            fs=fs,
                            record_fn=record_fn,
                        )
                        aux = input("Press any key... ")
                        if aux == "q":
                            break

        not_plotting_print(
            plotting=plotting,
            count=count,
            T=T,
            UniquePatients=UniquePatients,
            MaxSegments_per_patient=MaxSegments_per_patient,
            UniquePatientsMax=UniquePatientsMax,
            fout=fout,
            fpout=fpout,
        )


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-f", "--fname", type=str, required=True)
    parser.add_argument("-d", "--dbpath", type=str, required=True)
    parser.add_argument("-i", "--invppg", action="store_true")
    parser.add_argument("-T", "--duration", type=int, required=True)
    parser.add_argument("-v", "--verbose", action="store_true")
    parser.add_argument("-p", "--plotting", action="store_true")
    args = parser.parse_args()
    main(args)
